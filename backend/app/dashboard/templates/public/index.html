{% extends "base.html" %}

{% block title %}MindRouter2 - Cluster Status{% endblock %}

{% block content %}
<div class="container py-4">
    <div class="row mb-4">
        <div class="col-12">
            <h1><i class="bi bi-speedometer2"></i> Cluster Status</h1>
            <p class="text-muted">Real-time status of the MindRouter2 inference cluster</p>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-md-3 mb-3">
            <div class="card card-stat success h-100">
                <div class="card-body">
                    <h2 class="card-subtitle mb-2 text-muted h6">Healthy Backends</h2>
                    <p class="card-title mb-0 h2">{{ healthy_backends }} / {{ total_backends }}</p>
                </div>
            </div>
        </div>
        <div class="col-md-3 mb-3">
            <div class="card card-stat primary h-100">
                <div class="card-body">
                    <h2 class="card-subtitle mb-2 text-muted h6">Available Models</h2>
                    <p class="card-title mb-0 h2">{{ models|length }}</p>
                </div>
            </div>
        </div>
        <div class="col-md-3 mb-3">
            <div class="card card-stat warning h-100">
                <div class="card-body">
                    <h2 class="card-subtitle mb-2 text-muted h6">Queue Size</h2>
                    <p class="card-title mb-0 h2">{{ queue_size }}</p>
                </div>
            </div>
        </div>
        <div class="col-md-3 mb-3">
            <div class="card card-stat primary h-100">
                <div class="card-body">
                    <h2 class="card-subtitle mb-2 text-muted h6">Status</h2>
                    <p class="card-title mb-0 h2">
                        {% if healthy_backends > 0 %}
                        <span class="text-success"><i class="bi bi-check-circle" aria-hidden="true"></i> Online</span>
                        {% else %}
                        <span class="text-danger"><i class="bi bi-x-circle" aria-hidden="true"></i> Offline</span>
                        {% endif %}
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Token Flow Animation -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card" style="overflow:hidden; background:#0a0e1a;">
                <div class="card-header" style="background:#0d1225; border-bottom:1px solid #1a2040; color:#8892b0;">
                    <i class="bi bi-activity"></i> Token Flow &mdash; Live Cluster Throughput
                </div>
                <div class="card-body p-0" style="position:relative; height:280px;">
                    <canvas id="tokenFlowCanvas" style="width:100%; height:100%; display:block;"
                            role="img" aria-label="Animated visualization of token flow through the inference cluster. Particles flow from request sources through the MindRouter hub to backend servers."></canvas>
                    <!-- Overlay stats (live region for screen readers) -->
                    <div id="flowStats" style="position:absolute; top:2px; left:50%; transform:translateX(-50%); text-align:center; pointer-events:none;" aria-live="polite" aria-atomic="true">
                        <div style="font-size:2rem; font-weight:700; color:#64ffda; line-height:1; text-shadow:0 0 20px rgba(100,255,218,0.4);">
                            <span id="tpsValue">0</span>
                            <span style="font-size:0.9rem; font-weight:400; color:#8892b0;"> tok/s</span>
                        </div>
                        <div style="font-size:0.8rem; color:#5a6380; margin-top:4px;">
                            <span id="rpmValue">0</span> requests/min
                            &nbsp;&middot;&nbsp;
                            <span id="activeValue">0</span> active
                        </div>
                    </div>
                    <!-- Screen reader summary (updated periodically) -->
                    <div id="flowStatsSR" class="sr-only" aria-live="polite" role="status"></div>
                    <!-- Idle label -->
                    <div id="idleLabel" style="position:absolute; bottom:12px; left:16px; font-size:0.75rem; color:#3a4060; pointer-events:none;" role="status">
                        Waiting for inference requests...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-cpu"></i> Available Models
                </div>
                <div class="card-body">
                    {% if models %}
                    <div class="row">
                        {% for model in models %}
                        <div class="col-md-4 mb-2">
                            <span class="badge bg-secondary"><i class="bi bi-box"></i> {{ model }}</span>
                        </div>
                        {% endfor %}
                    </div>
                    {% else %}
                    <p class="text-muted mb-0">No models currently available.</p>
                    {% endif %}
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-lightning"></i> Quick Start
                </div>
                <div class="card-body">
                    <p>To use the MindRouter2 API:</p>
                    <ol class="mb-0">
                        <li><a href="/request-api-key">Request an API key</a></li>
                        <li>Wait for admin approval</li>
                        <li>Use the OpenAI-compatible API</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-code-slash"></i> API Usage Example
                </div>
                <div class="card-body">
                    <pre class="bg-dark text-light p-3 rounded"><code>curl -X POST {{ request.url.scheme }}://{{ request.url.netloc }}/v1/chat/completions \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "{% if models %}{{ models[0] }}{% else %}llama3.2{% endif %}",
    "messages": [{"role": "user", "content": "Hello!"}]
  }'</code></pre>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
(function() {
    const canvas = document.getElementById('tokenFlowCanvas');
    const ctx = canvas.getContext('2d');
    const tpsEl = document.getElementById('tpsValue');
    const rpmEl = document.getElementById('rpmValue');
    const activeEl = document.getElementById('activeValue');
    const idleEl = document.getElementById('idleLabel');
    const srEl = document.getElementById('flowStatsSR');

    let W, H;
    const dpr = window.devicePixelRatio || 1;

    function resize() {
        const rect = canvas.parentElement.getBoundingClientRect();
        W = rect.width;
        H = rect.height;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        layoutNodes();
    }

    // --- Network topology ---
    const NODE_RADIUS = 6;
    let nodes = [];
    let edges = [];
    let inputNodes = [];
    let hubNode = null;
    let outputNodes = [];

    function layoutNodes() {
        nodes = [];
        edges = [];
        inputNodes = [];
        outputNodes = [];

        const cx = W / 2;
        const cy = H / 2;

        // Input nodes (left) - incoming requests
        const inputCount = 5;
        for (let i = 0; i < inputCount; i++) {
            const y = cy + (i - (inputCount - 1) / 2) * 40;
            const node = { x: W * 0.1, y: y, type: 'input', r: NODE_RADIUS };
            nodes.push(node);
            inputNodes.push(node);
        }

        // Central hub - the router
        hubNode = { x: cx, y: cy, type: 'hub', r: NODE_RADIUS * 2.5 };
        nodes.push(hubNode);

        // Output nodes (right) - backends
        const rawCount = {{ total_backends if total_backends > 0 else 4 }};
        const actualCount = Math.max(3, Math.min(rawCount, 8));
        for (let i = 0; i < actualCount; i++) {
            const y = cy + (i - (actualCount - 1) / 2) * 38;
            const node = { x: W * 0.9, y: y, type: 'output', r: NODE_RADIUS };
            nodes.push(node);
            outputNodes.push(node);
        }

        // Edges: input->hub, hub->output
        for (const inp of inputNodes) {
            edges.push({ from: inp, to: hubNode });
        }
        for (const out of outputNodes) {
            edges.push({ from: hubNode, to: out });
        }
    }

    // --- Particles ---
    const particles = [];
    const PARTICLE_POOL_MAX = 800;

    const COLORS = [
        { r: 100, g: 255, b: 218 },
        { r: 72,  g: 202, b: 228 },
        { r: 144, g: 224, b: 239 },
        { r: 86,  g: 198, b: 170 },
        { r: 130, g: 170, b: 255 },
    ];

    function spawnParticle() {
        if (particles.length >= PARTICLE_POOL_MAX) return;
        const inp = inputNodes[Math.floor(Math.random() * inputNodes.length)];
        const out = outputNodes[Math.floor(Math.random() * outputNodes.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const speed = 0.003 + Math.random() * 0.004;
        const size = 1.5 + Math.random() * 2.5;

        particles.push({
            x: inp.x, y: inp.y,
            seg: 0,
            t: 0,
            from: inp,
            mid: hubNode,
            to: out,
            speed: speed,
            size: size,
            color: color,
            alpha: 0.6 + Math.random() * 0.4,
            trail: [],
        });
    }

    // --- Throughput state ---
    let currentTPS = 0;
    let displayTPS = 0;
    let currentRPM = 0;
    let currentActive = 0;

    async function fetchThroughput() {
        try {
            const resp = await fetch('/api/cluster/throughput');
            if (resp.ok) {
                const data = await resp.json();
                currentTPS = data.tokens_per_second || 0;
                currentRPM = data.requests_per_minute || 0;
                currentActive = data.active_requests || 0;
                // Update screen reader summary
                if (srEl) srEl.textContent = currentTPS + ' tokens per second, ' + currentRPM + ' recent requests, ' + currentActive + ' active';
            }
        } catch (e) { /* retry next cycle */ }
    }

    fetchThroughput();
    setInterval(fetchThroughput, 5000);

    // --- Drawing helpers ---
    function drawEdge(edge, alpha) {
        ctx.beginPath();
        ctx.moveTo(edge.from.x, edge.from.y);
        const mx = (edge.from.x + edge.to.x) / 2;
        const my = (edge.from.y + edge.to.y) / 2;
        const offset = (edge.from.y - edge.to.y) * 0.15;
        ctx.quadraticCurveTo(mx + offset, my, edge.to.x, edge.to.y);
        ctx.strokeStyle = 'rgba(30, 45, 80, ' + alpha + ')';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawNode(node) {
        const glow = node.type === 'hub' ? 12 : 6;
        const baseColor = node.type === 'hub'
            ? { r: 100, g: 255, b: 218 }
            : node.type === 'input'
                ? { r: 72, g: 202, b: 228 }
                : { r: 130, g: 170, b: 255 };
        // Log-scaled glow: grows smoothly from idle through thousands of tps
        const logTPS = currentTPS > 0 ? Math.log10(1 + currentTPS) : 0;
        const intensity = node.type === 'hub'
            ? 0.12 + Math.min(logTPS * 0.2, 0.75)
            : 0.08 + Math.min(logTPS * 0.12, 0.45);

        // Glow
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.r + glow, 0, Math.PI * 2);
        const grad = ctx.createRadialGradient(node.x, node.y, node.r, node.x, node.y, node.r + glow);
        grad.addColorStop(0, 'rgba(' + baseColor.r + ',' + baseColor.g + ',' + baseColor.b + ',' + intensity + ')');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fill();

        // Core
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(' + baseColor.r + ',' + baseColor.g + ',' + baseColor.b + ',' + (0.3 + intensity) + ')';
        ctx.fill();

        if (node.type === 'hub') {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.r + 2, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(100,255,218,' + (0.2 + intensity * 0.5) + ')';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
    }

    function drawParticle(p) {
        // Trail
        if (p.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let i = 1; i < p.trail.length; i++) {
                ctx.lineTo(p.trail[i].x, p.trail[i].y);
            }
            ctx.strokeStyle = 'rgba(' + p.color.r + ',' + p.color.g + ',' + p.color.b + ',' + (p.alpha * 0.15) + ')';
            ctx.lineWidth = p.size * 0.6;
            ctx.stroke();
        }

        // Glow
        const glowR = p.size * 3;
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
        grad.addColorStop(0, 'rgba(' + p.color.r + ',' + p.color.g + ',' + p.color.b + ',' + (p.alpha * 0.5) + ')');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Core
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(' + p.color.r + ',' + p.color.g + ',' + p.color.b + ',' + p.alpha + ')';
        ctx.fill();
    }

    function curvePoint(from, to, t) {
        const mx = (from.x + to.x) / 2;
        const my = (from.y + to.y) / 2;
        const offset = (from.y - to.y) * 0.15;
        const ct = 1 - t;
        return {
            x: ct * ct * from.x + 2 * ct * t * (mx + offset) + t * t * to.x,
            y: ct * ct * from.y + 2 * ct * t * my + t * t * to.y,
        };
    }

    // --- Animation loop ---
    let lastTime = 0;
    const TRAIL_LENGTH = 8;

    function animate(time) {
        requestAnimationFrame(animate);
        const dt = Math.min(time - lastTime, 50);
        lastTime = time;

        // Smooth TPS display
        displayTPS += (currentTPS - displayTPS) * 0.08;
        tpsEl.textContent = displayTPS < 1 ? displayTPS.toFixed(1) : Math.round(displayTPS);
        rpmEl.textContent = currentRPM;
        activeEl.textContent = currentActive;

        idleEl.style.display = (currentTPS < 0.1 && currentActive === 0) ? 'block' : 'none';

        // Spawn rate: log-scaled, no hard cap
        // idle (~0 tps): ~0.12/sec (one particle every ~8s)
        // 100 tps: ~24/sec, 1000 tps: ~36/sec, 5000 tps: ~45/sec
        const spawnRate = 0.12 + (currentTPS > 0 ? Math.log10(1 + currentTPS) * 12 : 0);
        const spawnCount = Math.max(0, Math.floor(spawnRate * dt / 1000 + Math.random()));
        for (let i = 0; i < spawnCount; i++) spawnParticle();

        // Speed: log-scaled so it keeps growing into thousands of tps
        // idle: 0.7x (lazy drift), 100 tps: ~3.7x, 1000 tps: ~5.2x, 5000 tps: ~6.3x
        const speedMultiplier = 0.7 + (currentTPS > 0 ? Math.log10(1 + currentTPS) * 1.5 : 0);

        // Clear & background
        ctx.clearRect(0, 0, W, H);
        const bg = ctx.createLinearGradient(0, 0, W, 0);
        bg.addColorStop(0, '#080c18');
        bg.addColorStop(0.5, '#0a0e1a');
        bg.addColorStop(1, '#080c18');
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);

        // Edges: log-scaled brightness
        const edgeLogTPS = currentTPS > 0 ? Math.log10(1 + currentTPS) : 0;
        const edgeAlpha = 0.25 + Math.min(edgeLogTPS * 0.15, 0.55);
        for (const edge of edges) drawEdge(edge, edgeAlpha);

        // Update & draw particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.t += p.speed * speedMultiplier * (dt / 16);

            if (p.t >= 1) {
                if (p.seg === 0) {
                    p.seg = 1;
                    p.t = 0;
                    p.trail = [];
                } else {
                    particles.splice(i, 1);
                    continue;
                }
            }

            const from = p.seg === 0 ? p.from : p.mid;
            const to = p.seg === 0 ? p.mid : p.to;
            const pt = curvePoint(from, to, p.t);
            p.x = pt.x;
            p.y = pt.y;

            p.trail.push({ x: p.x, y: p.y });
            if (p.trail.length > TRAIL_LENGTH) p.trail.shift();

            drawParticle(p);
        }

        // Nodes on top
        for (const node of nodes) drawNode(node);

        // Labels
        ctx.font = '10px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';

        if (inputNodes.length > 0) {
            ctx.fillStyle = 'rgba(90, 99, 128, 0.7)';
            ctx.fillText('Requests', inputNodes[0].x, inputNodes[0].y - 30);
        }
        if (hubNode) {
            ctx.fillStyle = 'rgba(100, 255, 218, 0.6)';
            ctx.font = '11px system-ui, -apple-system, sans-serif';
            ctx.fillText('MindRouter', hubNode.x, hubNode.y - hubNode.r - 12);
        }
        if (outputNodes.length > 0) {
            ctx.fillStyle = 'rgba(90, 99, 128, 0.7)';
            ctx.font = '10px system-ui, -apple-system, sans-serif';
            ctx.fillText('Backends', outputNodes[0].x, outputNodes[0].y - 30);
        }
    }

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(animate);
})();
</script>
{% endblock %}
